<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flux</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100dvh; /* Dynamic viewport height for mobile */
            background: #fefefe;
            font-family: 'Poppins', sans-serif;
            color: #1a1a1a;
            padding: 20px;
            padding-bottom: env(safe-area-inset-bottom, 20px); /* Account for iOS safe area */
            overflow: auto;
        }

        #game-container {
            text-align: center;
            max-width: 500px;
            width: 100%;
            max-height: calc(100vh - 40px);
            max-height: calc(100dvh - 40px); /* Dynamic viewport height */
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px 20px;
            padding-bottom: 30px; /* Extra padding for mobile */
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.08);
            backdrop-filter: blur(10px);
        }

        header {
            margin-bottom: 15px;
            position: relative;
        }

        h1 {
            font-size: 38px;
            font-weight: 900;
            letter-spacing: 0.1em;
            margin-bottom: 5px;
            background: linear-gradient(to right, #1a1a1a, #666);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .help-btn {
            position: absolute;
            top: 0;
            right: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #e0e0e0;
            background: white;
            color: #666;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-btn:hover {
            border-color: #4ade80;
            color: #4ade80;
            transform: scale(1.1);
        }

        #subtitle {
            color: #666;
            font-size: 12px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #mode-toggle {
            display: inline-flex;
            background: #f0f0f0;
            border-radius: 25px;
            padding: 3px;
            margin-bottom: 12px;
        }

        .mode-btn {
            padding: 6px 14px;
            border: none;
            background: transparent;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            color: #666;
            position: relative;
        }

        .mode-btn.completed::after {
            content: 'âœ“';
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: #4ade80;
            color: #000;
            border-radius: 50%;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .mode-btn.active {
            background: #4ade80;
            color: #000;
            box-shadow: 0 2px 8px rgba(74, 222, 128, 0.3);
            font-weight: 600;
        }

        #stats {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            margin-bottom: 15px;
            font-size: 14px;
            flex-wrap: wrap;
        }

        .stat {
            color: #666;
        }

        .stat-value {
            font-weight: 600;
            color: #1a1a1a;
            font-size: 16px;
        }

        #game-area {
            position: relative;
            margin-bottom: 20px;
        }

        .grid {
            display: inline-grid;
            gap: 4px;
            background: #f0f0f0;
            padding: 4px;
            border-radius: 12px;
            position: relative;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        #player-grid.grid-4,
        #target-grid.grid-4 {
            display: inline-grid;
            grid-template-columns: repeat(4, 54px);
            grid-template-rows: repeat(4, 54px);
            gap: 4px;
        }

        #player-grid.grid-5,
        #target-grid.grid-5 {
            display: inline-grid;
            grid-template-columns: repeat(5, 43px);
            grid-template-rows: repeat(5, 43px);
            gap: 3px;
        }

        .cell {
            background: #4ade80;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: block;
            box-sizing: border-box;
            padding: 0;
            margin: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        button.cell {
            font-family: 'Poppins', sans-serif;
            font-size: inherit;
            line-height: 1;
        }

        .grid-5 .cell {
            border-radius: 6px;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4), transparent 50%);
            opacity: 1;
            transition: opacity 0.2s;
        }

        .cell.dark {
            background: #2d2d2d;
            transform: scale(0.95);
        }

        .cell.dark::before {
            opacity: 0;
        }

        .cell:hover:not(.animating) {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
        }
        
        /* Disable hover on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .cell:hover {
                transform: none;
                box-shadow: none;
            }
        }

        .cell.preview-light {
            background: #86efac !important;
        }

        .cell.preview-dark {
            background: #525252 !important;
        }

        .cell.animating {
            animation: flip 0.4s ease-in-out;
        }

        @keyframes flip {
            0% { transform: scale(1) rotateY(0); }
            50% { transform: scale(1.2) rotateY(90deg); }
            100% { transform: scale(1) rotateY(180deg); }
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(74, 222, 128, 0.3);
            transform: scale(0);
            animation: ripple-effect 0.6s ease-out;
            pointer-events: none;
        }

        @keyframes ripple-effect {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* Overlay Styles */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: white;
            border-radius: 16px;
            padding: 28px;
            max-width: 480px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: none;
            border: none;
            font-size: 32px;
            color: #666;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .close-btn:hover {
            background: #f0f0f0;
        }

        .modal h2 {
            font-size: 26px;
            font-weight: 700;
            margin: 0 0 8px 0;
            color: #1a1a1a;
        }

        .modal .subtitle {
            color: #666;
            font-size: 15px;
            margin: 0 0 20px 0;
        }

        .tutorial-section {
            margin: 20px 0;
        }

        .tutorial-section h3 {
            font-size: 17px;
            font-weight: 600;
            margin: 0 0 14px 0;
            color: #1a1a1a;
        }

        .example-grid {
            margin: 20px 0;
        }

        .mini-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, 36px);
            grid-template-rows: repeat(3, 36px);
            gap: 3px;
            background: #f0f0f0;
            padding: 3px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .mini-grid.target {
            transform: scale(0.8);
            opacity: 0.8;
        }

        .mini-cell {
            border-radius: 4px;
            transition: all 0.2s;
        }

        .mini-cell.light {
            background: #4ade80;
        }

        .mini-cell.dark {
            background: #2d2d2d;
        }

        .mini-cell.highlight {
            box-shadow: 0 0 0 2px #fbbf24;
        }

        .mini-cell.center-highlight {
            box-shadow: 0 0 0 3px #ef4444;
            transform: scale(1.1);
        }

        .example-text {
            font-size: 14px;
            color: #333;
            line-height: 1.5;
            margin: 0;
        }

        .example-text strong {
            color: #1a1a1a;
            font-weight: 600;
        }

        .tutorial-footer {
            margin-top: 28px;
            text-align: center;
            border-top: 1px solid #e0e0e0;
            padding-top: 20px;
        }

        .tutorial-footer p {
            color: #666;
            font-size: 13px;
            margin: 0 0 14px 0;
        }

        .play-btn {
            background: #4ade80;
            color: #000;
            padding: 11px 42px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .play-btn:hover {
            background: #22c55e;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }

        /* Win Modal Styles */
        .win-modal {
            text-align: center;
            padding: 36px;
            max-width: 420px;
            position: relative;
            overflow: hidden;
        }

        .win-modal::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at center, rgba(74, 222, 128, 0.02) 0%, transparent 70%);
            pointer-events: none;
        }

        .modal-header {
            margin-bottom: 28px;
            position: relative;
            z-index: 1;
        }

        .win-modal h2 {
            font-size: 26px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .win-subtitle {
            font-size: 15px;
            color: #666;
            margin: 0;
            font-weight: 400;
        }

        .win-stats {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0;
            margin: 0 auto 30px;
            background: #f8f8f8;
            border-radius: 12px;
            padding: 20px 0;
            max-width: 280px;
            position: relative;
            z-index: 1;
        }

        .win-stat {
            flex: 1;
            text-align: center;
        }

        .win-stat-divider {
            width: 1px;
            height: 40px;
            background: #e0e0e0;
            margin: 0 24px;
        }

        .win-stat-label {
            display: block;
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .win-stat-value {
            display: block;
            font-size: 28px;
            font-weight: 700;
            color: #1a1a1a;
            line-height: 1;
        }

        .win-grid-preview {
            margin: 0 auto 30px;
            position: relative;
            z-index: 1;
            display: inline-block;
        }

        .modal-grid {
            display: inline-grid;
            background: #f0f0f0;
            padding: 4px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .modal-grid-4 {
            grid-template-columns: repeat(4, 44px);
            grid-template-rows: repeat(4, 44px);
            gap: 4px;
        }

        .modal-grid-5 {
            grid-template-columns: repeat(5, 35px);
            grid-template-rows: repeat(5, 35px);
            gap: 3px;
        }

        .modal-cell {
            background: #4ade80;
            border-radius: 8px;
            transition: all 0.2s;
            position: relative;
        }

        .modal-cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4), transparent 50%);
            opacity: 1;
            transition: opacity 0.2s;
            border-radius: 8px;
        }

        .modal-cell.dark {
            background: #2d2d2d;
            transform: scale(0.95);
        }

        .modal-cell.dark::before {
            opacity: 0;
        }

        .modal-grid-5 .modal-cell {
            border-radius: 6px;
        }

        .modal-grid-5 .modal-cell::before {
            border-radius: 6px;
        }

        .win-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            position: relative;
            z-index: 1;
        }

        .share-modal-btn {
            background: #1a1a1a;
            color: white;
            padding: 13px 32px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            flex: 1;
            max-width: 180px;
        }

        .share-modal-btn:hover {
            background: #000;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .close-modal-btn {
            background: transparent;
            color: #666;
            padding: 13px 32px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            flex: 1;
            max-width: 180px;
        }

        .close-modal-btn:hover {
            background: #f5f5f5;
            border-color: #ccc;
            color: #333;
        }

        #target-display {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        #target-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666;
            margin-bottom: 12px;
        }

        #target-grid {
            transform: scale(0.6);
            opacity: 0.6;
            pointer-events: none;
        }

        #target-grid.grid-5 {
            transform: scale(0.65);
        }

        #actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #reset-btn {
            background: #e0e0e0;
            color: #666;
        }

        #reset-btn:hover {
            background: #d0d0d0;
            color: #333;
        }

        #reset-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #reset-btn.inactive {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #reset-btn.inactive:hover {
            background: #e0e0e0;
            color: #666;
            transform: none;
        }

        .completed-indicator {
            display: inline-block;
            margin-left: 8px;
            padding: 4px 12px;
            background: #4ade80;
            color: #000;
            font-size: 11px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .completed-indicator.failed {
            background: #fbbf24;
        }

        .practice-indicator {
            color: #fbbf24;
            font-size: 12px;
            font-weight: 600;
            margin-left: 4px;
        }

        #share-btn {
            background: #1a1a1a;
            color: #fff;
            opacity: 0.3;
            cursor: not-allowed;
        }

        #share-btn.active {
            opacity: 1;
            cursor: pointer;
            background: #000;
        }

        #share-btn.active:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        #message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            color: #4ade80;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        #message.show {
            opacity: 1;
        }

        #streak-display {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: 600;
            opacity: 0;
            transition: all 0.3s;
        }

        #streak-display.show {
            opacity: 1;
            animation: bounce 0.5s ease-out;
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        .particles {
            position: fixed;
            pointer-events: none;
            z-index: 100;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #4ade80;
            border-radius: 50%;
            animation: particle-float 1s ease-out forwards;
        }

        @keyframes particle-float {
            to {
                transform: translateY(-100px);
                opacity: 0;
            }
        }

        @media (max-width: 500px) {
            body {
                padding: 10px;
                padding-bottom: env(safe-area-inset-bottom, 10px);
            }
            
            #game-container {
                padding: 20px 15px 25px;
                max-height: none; /* Allow natural scrolling on mobile */
                height: auto;
            }
            
            h1 {
                font-size: 32px;
            }

            #player-grid.grid-4,
            #target-grid.grid-4 {
                grid-template-columns: repeat(4, 48px);
                grid-template-rows: repeat(4, 48px);
            }

            #player-grid.grid-5,
            #target-grid.grid-5 {
                grid-template-columns: repeat(5, 38px);
                grid-template-rows: repeat(5, 38px);
                gap: 2px;
            }

            .modal {
                padding: 20px;
                max-width: 95%;
                max-height: 85vh; /* Reduced height for mobile */
            }
            
            /* Compact tutorial modal for mobile */
            #tutorial-overlay .modal {
                padding: 20px 16px;
            }
            
            #tutorial-overlay .modal h2 {
                font-size: 22px;
                margin-bottom: 6px;
            }
            
            #tutorial-overlay .modal .subtitle {
                font-size: 14px;
                margin-bottom: 16px;
            }
            
            .tutorial-section {
                margin: 16px 0;
            }
            
            .tutorial-section h3 {
                font-size: 16px;
                margin-bottom: 10px;
            }
            
            .example-grid {
                margin: 16px 0;
            }
            
            .mini-grid {
                grid-template-columns: repeat(3, 32px);
                grid-template-rows: repeat(3, 32px);
                gap: 2px;
                padding: 2px;
                margin-bottom: 8px;
            }
            
            .example-text {
                font-size: 13px;
                margin-bottom: 0;
            }
            
            .tutorial-footer {
                margin-top: 20px;
                padding-top: 16px;
            }
            
            .tutorial-footer p {
                font-size: 12px;
                margin-bottom: 12px;
            }
            
            .play-btn {
                padding: 10px 36px;
                font-size: 14px;
            }

            .win-modal {
                padding: 28px 20px;
            }

            .modal h2 {
                font-size: 22px;
            }

            .win-stat-value {
                font-size: 24px;
            }

            .win-stats {
                padding: 18px 0;
            }

            .win-actions {
                flex-direction: column;
            }

            .share-modal-btn,
            .close-modal-btn {
                max-width: 100%;
            }

            .win-grid-preview {
                transform: scale(0.85);
            }

            .help-btn {
                width: 32px;
                height: 32px;
                font-size: 16px;
            }

            #stats {
                gap: 20px;
            }

            .completed-indicator {
                font-size: 10px;
                padding: 3px 8px;
            }
            
            /* Fix target grid spacing on mobile */
            #target-display {
                margin-top: 16px;
                padding-top: 16px;
            }
            
            /* Ensure buttons are always visible */
            #actions {
                margin-top: 12px;
                padding-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <header>
            <h1>FLUX</h1>
            <div id="subtitle">Daily Puzzle #<span id="puzzle-number"></span></div>
            <button class="help-btn" onclick="showTutorial()" title="How to play">?</button>
            <div id="mode-toggle">
                <button class="mode-btn active" onclick="setMode(4)">4Ã—4 Classic</button>
                <button class="mode-btn" onclick="setMode(5)">5Ã—5 Hard</button>
            </div>
        </header>

        <div id="stats">
            <div class="stat">Moves: <span class="stat-value" id="moves">0</span></div>
            <div class="stat">Best: <span class="stat-value" id="best">-</span></div>
        </div>

        <div id="game-area">
            <div id="player-grid" class="grid grid-4"></div>
        </div>

        <div id="target-display">
            <div id="target-label">Target Pattern</div>
            <div id="target-grid" class="grid grid-4"></div>
        </div>

        <div id="actions">
            <button id="reset-btn" onclick="resetPuzzle()">Reset</button>
            <button id="share-btn" onclick="shareResults()">Share</button>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="overlay">
        <div class="modal">
            <button class="close-btn" onclick="closeTutorial()">&times;</button>
            <h2>How To Play</h2>
            <p class="subtitle">Match the target pattern in 10 moves or less.</p>
            
            <div class="tutorial-section">
                <h3>Examples</h3>
                <div class="example-grid">
                    <div class="mini-grid">
                        <div class="mini-cell light"></div>
                        <div class="mini-cell dark highlight"></div>
                        <div class="mini-cell light"></div>
                        <div class="mini-cell dark"></div>
                        <div class="mini-cell dark center-highlight"></div>
                        <div class="mini-cell dark"></div>
                        <div class="mini-cell light"></div>
                        <div class="mini-cell dark"></div>
                        <div class="mini-cell light"></div>
                    </div>
                    <p class="example-text">Click a tile to flip it <strong>and its neighbors</strong> in a plus pattern.</p>
                </div>
                
                <div class="example-grid">
                    <div class="mini-grid target">
                        <div class="mini-cell dark"></div>
                        <div class="mini-cell dark"></div>
                        <div class="mini-cell light"></div>
                        <div class="mini-cell light"></div>
                        <div class="mini-cell dark"></div>
                        <div class="mini-cell light"></div>
                        <div class="mini-cell dark"></div>
                        <div class="mini-cell light"></div>
                        <div class="mini-cell dark"></div>
                    </div>
                    <p class="example-text">Match the <strong>target pattern</strong> shown below the game board.</p>
                </div>
            </div>
            
            <div class="tutorial-footer">
                <p>A new puzzle is released daily at midnight.</p>
                <button class="play-btn" onclick="closeTutorial()">Play</button>
            </div>
        </div>
    </div>

                <!-- Win Overlay -->
    <div id="win-overlay" class="overlay">
        <div class="modal win-modal">
            <button class="close-btn" onclick="closeWinOverlay()">&times;</button>
            <div class="modal-header">
                <h2>Congratulations</h2>
                <p class="win-subtitle">You solved today's puzzle</p>
            </div>
            
            <div class="win-stats">
                <div class="win-stat">
                    <span class="win-stat-label">Moves</span>
                    <span class="win-stat-value" id="win-moves">0</span>
                </div>
                <div class="win-stat-divider"></div>
                <div class="win-stat">
                    <span class="win-stat-label">Best</span>
                    <span class="win-stat-value" id="win-best">-</span>
                </div>
            </div>
            
            <div class="win-grid-preview" id="win-grid-preview"></div>
            
            <div class="win-actions">
                <button class="share-modal-btn" onclick="shareFromModal()">Share</button>
                <button class="close-modal-btn" onclick="closeWinModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="message"></div>
    <div id="streak-display">ðŸ”¥ <span id="streak-count">3</span> Day Streak!</div>
    <div class="particles" id="particles"></div>

    <script>
        let gridSize = 4;
        let moves = 0;
        let playerGrid = [];
        let targetGrid = [];
        let gameWon = false;
        let gameOver = false;
        let bestScores = {};
        let isAnimating = false;
        let practiceMode = false;
        let move10Grid = null; // Store grid state at move 10

        const playerGridEl = document.getElementById('player-grid');
        const targetGridEl = document.getElementById('target-grid');
        const movesEl = document.getElementById('moves');
        const bestEl = document.getElementById('best');
        const shareBtn = document.getElementById('share-btn');
        const messageEl = document.getElementById('message');
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const winOverlay = document.getElementById('win-overlay');

        // Load best scores
        const saved = localStorage.getItem('flux-best-moves');
        if (saved) bestScores = JSON.parse(saved);

        // Check if first time player (for tutorial)
        const hasPlayed = localStorage.getItem('flux-has-played');
        if (!hasPlayed) {
            setTimeout(() => {
                tutorialOverlay.classList.add('show');
            }, 500);
        }

        // Set puzzle number
        const today = new Date();
        const startDate = new Date('2025-07-29'); // Today's date for puzzle #001
        const dayNumber = Math.floor((today - startDate) / (1000 * 60 * 60 * 24)) + 1;
        document.getElementById('puzzle-number').textContent = dayNumber.toString().padStart(3, '0');

        // Check if today's puzzle has been completed
        function getTodaysSaveKey() {
            return `flux-puzzle-${dayNumber}-${gridSize}`;
        }

        function saveGameState() {
            // Don't save if in practice mode (only save the initial failure state)
            if (practiceMode) return;
            
            const saveData = {
                playerGrid: playerGrid,
                moves: moves,
                completed: gameWon || gameOver,
                won: gameWon,
                date: today.toISOString()
            };
            localStorage.setItem(getTodaysSaveKey(), JSON.stringify(saveData));
        }

        function loadGameState() {
            const saved = localStorage.getItem(getTodaysSaveKey());
            if (saved) {
                const data = JSON.parse(saved);
                return data;
            }
            return null;
        }

        // Tutorial and modal functions (global for onclick)
        window.closeTutorial = function() {
            tutorialOverlay.classList.remove('show');
            localStorage.setItem('flux-has-played', 'true');
        }

        window.showTutorial = function() {
            tutorialOverlay.classList.add('show');
        }

        // Close win overlay with X button
        function closeWinOverlay() {
            // If closing the game over modal without continuing, save the game as completed
            if (gameOver && !practiceMode && move10Grid) {
                const saveData = {
                    playerGrid: move10Grid,
                    moves: 10,
                    completed: true,
                    won: false,
                    date: today.toISOString()
                };
                localStorage.setItem(getTodaysSaveKey(), JSON.stringify(saveData));
                
                // Disable gameplay
                disableGameplay();
            }
            
            winOverlay.classList.remove('show');
            
            // Reset close button text
            const closeBtn = document.querySelector('.close-modal-btn');
            closeBtn.textContent = 'Close';
            closeBtn.onclick = closeWinModal;
        }

        window.closeWinOverlay = closeWinOverlay;
        
        window.closeWinModal = function() {
            closeWinOverlay();
        }

        window.shareFromModal = function() {
            shareResults();
        }

        // Check streak
        function checkStreak() {
            const lastPlayed = localStorage.getItem('flux-last-played');
            const streak = parseInt(localStorage.getItem('flux-streak') || '0');
            
            if (lastPlayed) {
                const lastDate = new Date(lastPlayed);
                const daysSince = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
                
                if (daysSince === 1) {
                    // Consecutive day
                    const newStreak = streak + 1;
                    localStorage.setItem('flux-streak', newStreak);
                    
                    if (newStreak >= 3) {
                        showStreak(newStreak);
                    }
                } else if (daysSince > 1) {
                    // Streak broken
                    localStorage.setItem('flux-streak', '1');
                }
            } else {
                localStorage.setItem('flux-streak', '1');
            }
            
            localStorage.setItem('flux-last-played', today.toISOString());
        }

        // Show streak notification
        function showStreak(days) {
            document.getElementById('streak-count').textContent = days;
            document.getElementById('streak-display').classList.add('show');
            setTimeout(() => {
                document.getElementById('streak-display').classList.remove('show');
            }, 3000);
        }

        // Set game mode
        function setMode(size) {
            gridSize = size;
            practiceMode = false;
            move10Grid = null;
            
            // Remove practice indicator if present
            const practiceIndicator = document.querySelector('.practice-indicator');
            if (practiceIndicator) {
                practiceIndicator.remove();
            }
            
            document.querySelectorAll('.mode-btn').forEach((btn, index) => {
                btn.classList.toggle('active', (size === 4 && index === 0) || (size === 5 && index === 1));
            });
            
            // Remove all grid classes first
            playerGridEl.className = 'grid';
            targetGridEl.className = 'grid';
            
            // Force reflow
            void playerGridEl.offsetHeight;
            
            // Add new grid class
            playerGridEl.classList.add(`grid-${size}`);
            targetGridEl.classList.add(`grid-${size}`);
            
            // Clear any existing completed indicator
            const indicator = document.querySelector('.completed-indicator');
            if (indicator) {
                indicator.remove();
            }
            
            initGame();
            updateModeButtons();
        }

        // Generate puzzle
        function generatePuzzle(size) {
            const seed = (dayNumber - 1) * 100 + size; // Subtract 1 since dayNumber now starts at 1
            let rng = seed;
            
            const grid = Array(size * size).fill(true);
            
            // Apply fewer moves for 4x4 to make it easier
            const targetMoves = size === 4 ? 3 + (seed % 2) : 4 + (seed % 3); // 3-4 moves for 4x4, 4-6 for 5x5
            const movesToMake = [];
            
            // Ensure we get exactly the target number of moves
            while (movesToMake.length < targetMoves) {
                rng = (rng * 1103515245 + 12345) & 0x7fffffff;
                const pos = rng % (size * size);
                if (!movesToMake.includes(pos)) {
                    movesToMake.push(pos);
                }
            }
            
            movesToMake.forEach(index => {
                toggleCellPattern(grid, index, size);
            });
            
            return grid;
        }

        // Toggle cell and neighbors
        function toggleCellPattern(grid, index, size) {
            grid[index] = !grid[index];
            
            const row = Math.floor(index / size);
            const col = index % size;
            
            if (row > 0) grid[index - size] = !grid[index - size];
            if (row < size - 1) grid[index + size] = !grid[index + size];
            if (col > 0) grid[index - 1] = !grid[index - 1];
            if (col < size - 1) grid[index + 1] = !grid[index + 1];
        }

        // Initialize game
        function initGame() {
            // Check if this puzzle was already played today
            const savedState = loadGameState();
            
            if (savedState) {
                if (savedState.completed) {
                    // Load the completed state
                    playerGrid = savedState.playerGrid;
                    moves = savedState.moves;
                    gameWon = savedState.won;
                    gameOver = !savedState.won;
                    movesEl.textContent = moves;
                    shareBtn.classList.add('active');
                    
                    // If it was a failed attempt, set move10Grid for sharing
                    if (!savedState.won) {
                        move10Grid = [...savedState.playerGrid];
                    }
                    
                    // Generate the same target pattern
                    targetGrid = generatePuzzle(gridSize);
                    
                    updateBestDisplay();
                    renderGrids();
                    updateResetButton();
                    
                    // Disable all interactions
                    disableGameplay();
                    
                    // Show completion message
                    setTimeout(() => {
                        if (gameWon) {
                            showMessage('You completed today\'s puzzle in ' + moves + ' moves!');
                        } else {
                            showMessage('You attempted today\'s puzzle - try again tomorrow!');
                        }
                    }, 500);
                    
                    return;
                } else {
                    // Load in-progress game
                    playerGrid = savedState.playerGrid;
                    moves = savedState.moves;
                    gameWon = false;
                    gameOver = false;
                    isAnimating = false;
                    movesEl.textContent = moves;
                    shareBtn.classList.remove('active');
                    
                    // Generate the same target pattern
                    targetGrid = generatePuzzle(gridSize);
                    
                    updateBestDisplay();
                    renderGrids();
                    updateResetButton();
                    
                    // Check if already won on load (in case of refresh)
                    if (checkWin()) {
                        handleWin();
                    }
                    
                    return;
                }
            }
            
            // Normal initialization for new game
            moves = 0;
            gameWon = false;
            gameOver = false;
            isAnimating = false;
            practiceMode = false;
            move10Grid = null;
            movesEl.textContent = '0';
            shareBtn.classList.remove('active');
            
            playerGrid = Array(gridSize * gridSize).fill(true);
            targetGrid = generatePuzzle(gridSize);
            
            updateBestDisplay();
            renderGrids();
            updateResetButton();
            
            // Check if already won on load (in case of refresh)
            if (checkWin()) {
                handleWin();
            }
            
            // Check streak only on first load of the day
            if (!localStorage.getItem(`flux-played-${dayNumber.toString().padStart(3, '0')}`)) {
                checkStreak();
                localStorage.setItem(`flux-played-${dayNumber.toString().padStart(3, '0')}`, 'true');
            }
        }

        // Disable gameplay for completed puzzles
        function disableGameplay() {
            const cells = playerGridEl.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.cursor = 'default';
                cell.onclick = null;
                cell.onmouseenter = null;
                cell.onmouseleave = null;
                cell.blur(); // Remove focus on mobile
            });
            
            // Disable reset button
            const resetBtn = document.getElementById('reset-btn');
            resetBtn.classList.add('disabled');
            resetBtn.onclick = () => {
                showMessage('You can only play once per day!');
            };
            
            // Add completed indicator (only if not already in practice mode)
            const statsDiv = document.getElementById('stats');
            if (!document.querySelector('.completed-indicator') && !practiceMode) {
                const indicator = document.createElement('span');
                indicator.className = 'completed-indicator' + (gameWon ? '' : ' failed');
                indicator.textContent = gameWon ? 'Completed' : 'Attempted';
                statsDiv.appendChild(indicator);
            }
        }

        // Render grids
        function renderGrids() {
            playerGridEl.innerHTML = '';
            targetGridEl.innerHTML = '';
            
            for (let i = 0; i < gridSize * gridSize; i++) {
                // Player grid
                const playerCell = document.createElement('button');
                playerCell.className = 'cell' + (playerGrid[i] ? '' : ' dark');
                playerCell.onclick = () => clickCell(i);
                
                // Only add hover events on non-touch devices
                if (window.matchMedia('(hover: hover)').matches) {
                    playerCell.onmouseenter = () => showPreview(i);
                    playerCell.onmouseleave = () => hidePreview();
                }
                
                playerGridEl.appendChild(playerCell);
                
                // Target grid
                const targetCell = document.createElement('div');
                targetCell.className = 'cell' + (targetGrid[i] ? '' : ' dark');
                targetGridEl.appendChild(targetCell);
            }
        }

        // Show preview on hover
        function showPreview(index) {
            if (gameWon || gameOver || isAnimating) return;
            
            const cellsToFlip = [index];
            const row = Math.floor(index / gridSize);
            const col = index % gridSize;
            
            if (row > 0) cellsToFlip.push(index - gridSize);
            if (row < gridSize - 1) cellsToFlip.push(index + gridSize);
            if (col > 0) cellsToFlip.push(index - 1);
            if (col < gridSize - 1) cellsToFlip.push(index + 1);
            
            cellsToFlip.forEach(i => {
                const cell = playerGridEl.children[i];
                if (playerGrid[i]) {
                    cell.classList.add('preview-dark');
                } else {
                    cell.classList.add('preview-light');
                }
            });
        }

        // Hide preview
        function hidePreview() {
            const cells = playerGridEl.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('preview-dark', 'preview-light');
            });
        }

        // Handle cell click
        function clickCell(index) {
            if (gameWon || (gameOver && !practiceMode) || isAnimating) return;
            
            // Check if game was already completed (extra safety check)
            const savedState = loadGameState();
            if (savedState && savedState.completed) return;
            
            isAnimating = true;
            moves++;
            movesEl.textContent = moves;
            updateResetButton();
            
            // Hide preview
            hidePreview();
            
            // Remove any lingering hover states on mobile
            const allCells = playerGridEl.querySelectorAll('.cell');
            allCells.forEach(cell => {
                cell.blur();
            });
            
            // Create ripple effect
            const cell = playerGridEl.children[index];
            const rect = cell.getBoundingClientRect();
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.width = '20px';
            ripple.style.height = '20px';
            ripple.style.left = rect.left + rect.width / 2 - 10 + 'px';
            ripple.style.top = rect.top + rect.height / 2 - 10 + 'px';
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 600);
            
            // Animate cells
            const cellsToFlip = [index];
            const row = Math.floor(index / gridSize);
            const col = index % gridSize;
            
            if (row > 0) cellsToFlip.push(index - gridSize);
            if (row < gridSize - 1) cellsToFlip.push(index + gridSize);
            if (col > 0) cellsToFlip.push(index - 1);
            if (col < gridSize - 1) cellsToFlip.push(index + 1);
            
            // Apply flips with animation
            cellsToFlip.forEach((i, delay) => {
                setTimeout(() => {
                    const cell = playerGridEl.children[i];
                    cell.classList.add('animating');
                    
                    setTimeout(() => {
                        playerGrid[i] = !playerGrid[i];
                        cell.classList.toggle('dark');
                        cell.classList.remove('animating');
                        
                        // Check win after each cell flip completes
                        if (delay === cellsToFlip.length - 1) {
                            setTimeout(() => {
                                isAnimating = false;
                                
                                // Save game state after every move
                                if (!practiceMode) {
                                    saveGameState();
                                }
                                
                                if (checkWin()) {
                                    handleWin();
                                } else if (moves >= 10 && !practiceMode) {
                                    handleGameOver();
                                }
                            }, 100);
                        }
                    }, 200);
                }, delay * 50);
            });
        }

        // Create particle effects
        function createParticles(x, y, count) {
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = x + (Math.random() - 0.5) * 40 + 'px';
                    particle.style.top = y + (Math.random() - 0.5) * 40 + 'px';
                    document.getElementById('particles').appendChild(particle);
                    setTimeout(() => particle.remove(), 1000);
                }, i * 50);
            }
        }

        // Check win
        function checkWin() {
            return playerGrid.every((cell, i) => cell === targetGrid[i]);
        }

        // Handle win
        function handleWin() {
            gameWon = true;
            shareBtn.classList.add('active');
            
            // Save game state only if not in practice mode
            if (!practiceMode) {
                // Normal win within 10 moves
                saveGameState();
                
                // Update best score (based on fewest moves)
                if (!bestScores[gridSize] || moves < bestScores[gridSize]) {
                    bestScores[gridSize] = moves;
                    localStorage.setItem('flux-best-moves', JSON.stringify(bestScores));
                    updateBestDisplay();
                }
                
                // Update mode buttons to show completion
                updateModeButtons();
            }
            // If in practice mode, don't save or update anything
            
            // Show win modal
            setTimeout(() => {
                showWinModal();
            }, 500);
            
            // Celebration particles
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const x = Math.random() * window.innerWidth;
                    const y = window.innerHeight / 2;
                    createParticles(x, y, 10);
                }, i * 200);
            }
            
            // Disable further gameplay
            disableGameplay();
        }

        // Show win modal
        function showWinModal() {
            // Reset modal content for win
            if (practiceMode) {
                document.querySelector('.win-modal h2').textContent = 'Puzzle Solved!';
                document.querySelector('.win-subtitle').textContent = `Completed in ${moves} moves (practice mode)`;
            } else {
                document.querySelector('.win-modal h2').textContent = 'Congratulations';
                document.querySelector('.win-subtitle').textContent = 'You solved today\'s puzzle';
            }
            
            // Update win stats
            document.getElementById('win-moves').textContent = moves;
            document.getElementById('win-best').textContent = bestScores[gridSize] || moves;
            
            // Create grid preview
            const preview = document.getElementById('win-grid-preview');
            preview.innerHTML = '';
            
            const modalGrid = document.createElement('div');
            modalGrid.className = `modal-grid modal-grid-${gridSize}`;
            
            for (let i = 0; i < gridSize * gridSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'modal-cell' + (playerGrid[i] ? '' : ' dark');
                modalGrid.appendChild(cell);
            }
            
            preview.appendChild(modalGrid);
            
            // Show modal
            winOverlay.classList.add('show');
        }

        // Close win modal
        function closeWinModal() {
            winOverlay.classList.remove('show');
        }



        // Handle game over (10 moves reached)
        function handleGameOver() {
            // Mark as game over but don't disable yet
            gameOver = true;
            shareBtn.classList.add('active');
            
            // Save the grid state at move 10 for sharing
            move10Grid = [...playerGrid];
            
            // Count correct dark tiles
            const correctTiles = playerGrid.filter((cell, i) => cell === targetGrid[i]).length;
            
            // Show game over modal (reuse win modal with different content)
            document.querySelector('.win-modal h2').textContent = 'Nice Try';
            document.querySelector('.win-subtitle').textContent = `You got ${correctTiles} of ${gridSize * gridSize} tiles correct`;
            document.getElementById('win-moves').textContent = moves;
            document.getElementById('win-best').textContent = bestScores[gridSize] || '-';
            
            // Change the close button text to "Keep Trying"
            const closeBtn = document.querySelector('.close-modal-btn');
            closeBtn.textContent = 'Keep Trying';
            closeBtn.onclick = () => {
                continueInPracticeMode();
            };
            
            // Create grid preview showing move 10 state
            const preview = document.getElementById('win-grid-preview');
            preview.innerHTML = '';
            
            const modalGrid = document.createElement('div');
            modalGrid.className = `modal-grid modal-grid-${gridSize}`;
            
            for (let i = 0; i < gridSize * gridSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'modal-cell' + (move10Grid[i] ? '' : ' dark');
                modalGrid.appendChild(cell);
            }
            
            preview.appendChild(modalGrid);
            
            // Show modal
            winOverlay.classList.add('show');
        }

        // Update best score display
        function updateBestDisplay() {
            bestEl.textContent = bestScores[gridSize] || '-';
        }

        // Reset puzzle
        function resetPuzzle() {
            // Check if already completed AND not in practice mode
            const savedState = loadGameState();
            if (savedState && savedState.completed && !practiceMode && !gameOver) {
                showMessage('You can only play once per day!');
                return;
            }
            
            // Don't allow reset if no moves have been made
            if (moves === 0) {
                return;
            }
            
            // Reset grid state and moves counter
            moves = 0;
            movesEl.textContent = '0';
            gameWon = false;
            gameOver = false;
            isAnimating = false;
            
            // If in practice mode, keep the share button active
            if (practiceMode) {
                shareBtn.classList.add('active');
            } else {
                shareBtn.classList.remove('active');
            }
            
            playerGrid = Array(gridSize * gridSize).fill(true);
            
            renderGrids();
            updateResetButton();
            
            // Save the reset state
            if (!practiceMode) {
                saveGameState();
            }
        }

        // Update reset button state
        function updateResetButton() {
            const resetBtn = document.getElementById('reset-btn');
            if (moves === 0) {
                resetBtn.classList.add('inactive');
            } else {
                resetBtn.classList.remove('inactive');
            }
        }

        // Continue in practice mode after failing
        function continueInPracticeMode() {
            practiceMode = true;
            gameOver = false; // Allow clicking tiles again
            
            // Close the modal
            winOverlay.classList.remove('show');
            
            // Reset close button for future use
            const closeBtn = document.querySelector('.close-modal-btn');
            closeBtn.textContent = 'Close';
            closeBtn.onclick = closeWinModal;
            
            // Add practice indicator to UI
            const movesDiv = document.querySelector('.stat');
            if (!movesDiv.querySelector('.practice-indicator')) {
                const indicator = document.createElement('span');
                indicator.className = 'practice-indicator';
                indicator.textContent = ' (practice)';
                movesDiv.appendChild(indicator);
            }
            
            // Re-render grids to ensure click handlers are attached
            renderGrids();
            
            // Re-enable reset button for practice mode
            const resetBtn = document.getElementById('reset-btn');
            resetBtn.classList.remove('disabled');
            resetBtn.onclick = resetPuzzle;
            updateResetButton();
            
            // Keep share button active
            shareBtn.classList.add('active');
            
            // Show message that they're in practice mode
            showMessage('Now in practice mode - solve it for fun! ðŸŽ¯');
        }

        // Show message
        function showMessage(text) {
            messageEl.textContent = text;
            messageEl.classList.add('show');
            setTimeout(() => messageEl.classList.remove('show'), 2000);
        }

        // Share results
        function shareResults() {
            // Allow sharing if: won, in practice mode (with move10Grid), or game over
            if (!gameWon && !move10Grid && !gameOver) return;
            
            // Use move 10 grid state if available (for practice mode or game over)
            const gridToShare = (practiceMode && move10Grid) || (gameOver && move10Grid) ? move10Grid : playerGrid;
            
            const emoji = gridToShare.map(lit => lit ? 'ðŸŸ©' : 'â¬›');
            const rows = [];
            for (let i = 0; i < gridSize; i++) {
                rows.push(emoji.slice(i * gridSize, (i + 1) * gridSize).join(''));
            }
            
            let resultText;
            const modeText = gridSize === 5 ? ' (Hard)' : '';
            if (gameWon && !practiceMode) {
                resultText = `FLUX ${dayNumber.toString().padStart(3, '0')}${modeText}\n` +
                            `${moves}/10\n\n`;
            } else {
                resultText = `FLUX ${dayNumber.toString().padStart(3, '0')}${modeText}\n` +
                            `X/10\n\n`;
            }
            
            const text = resultText + rows.join('\n') + '\n\nPlay FLUX at: flux.game';
            
            navigator.clipboard.writeText(text).then(() => {
                showMessage('Copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showMessage('Failed to copy to clipboard');
            });
        }

        // Force check win state (for debugging)
        function forceCheckWin() {
            // Don't check if already completed today
            const savedState = loadGameState();
            if (savedState && savedState.completed) {
                return;
            }
            
            if (checkWin() && !gameWon) {
                handleWin();
            }
        }

        // Expose functions for onclick handlers
        window.setMode = setMode;
        window.resetPuzzle = resetPuzzle;
        window.shareResults = shareResults;
        window.updateModeButtons = updateModeButtons;
        window.continueInPracticeMode = continueInPracticeMode;
        
        // Check completion status for both modes
        function updateModeButtons() {
            const modeBtns = document.querySelectorAll('.mode-btn');
            let completedCount = 0;
            
            // Check 4x4 completion
            const saved4x4 = localStorage.getItem(`flux-puzzle-${dayNumber}-4`);
            if (saved4x4) {
                const data = JSON.parse(saved4x4);
                if (data.completed) {
                    // Show checkmark only if won within 10 moves
                    if (data.won) {
                        modeBtns[0].classList.add('completed');
                        completedCount++;
                    }
                }
            }
            
            // Check 5x5 completion
            const saved5x5 = localStorage.getItem(`flux-puzzle-${dayNumber}-5`);
            if (saved5x5) {
                const data = JSON.parse(saved5x5);
                if (data.completed) {
                    // Show checkmark only if won within 10 moves
                    if (data.won) {
                        modeBtns[1].classList.add('completed');
                        completedCount++;
                    }
                }
            }
            
            // Check if both modes completed
            if (completedCount === 2 && !sessionStorage.getItem(`flux-both-completed-${dayNumber}`)) {
                sessionStorage.setItem(`flux-both-completed-${dayNumber}`, 'true');
                setTimeout(() => {
                    showMessage('Perfect Day! Both puzzles completed!');
                }, 1000);
            }
        }

        // Initialize
        initGame();
        updateModeButtons();
        
        // Add debug check on load
        setTimeout(forceCheckWin, 500);
    </script>
</body>
</html>
